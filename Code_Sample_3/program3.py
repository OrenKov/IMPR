import numpy as np
import scipy as scp
import scipy.ndimage.filters as filters
import os
import imageio
from skimage.color import rgb2gray
import matplotlib.pyplot as plt


def read_image(filename, representation):
    """
    This function returns an image (RGB or grayscale) from filename and representation.
    :param filename the filename of an image on disk (RGB or grayscale)
    :param representation representation code of the output, either 1 (grayscale img) or 2 (RGB img)
    :return an image (np.float64 type) with intensities, normalized to the range [0,1]
    """
    # Get original image, and store the 'float64' one:
    image = imageio.imread(filename)
    img = image.astype('float64')

    # Normalize to [0,1]:
    img /= 255.0
    if representation == 1:
        img = rgb2gray(img)

    return img


def relpath(filename):
    return os.path.join(os.path.dirname(__file__), filename)


#   (1) - Gaussian & Laplacian pyramid construction
# Helpers
def reduce(im, filter_vec):
    """
    reduce the size of an image. An helper for building a laplacian pyramid.
    """
    blurred = filters.convolve(filters.convolve(im, filter_vec), filter_vec.T)
    sampled = blurred[::2, ::2]
    return sampled


def expand(im, filter_vec):
    """
    expands a given image. An helper
    """
    expanded = np.zeros(shape=(im.shape[0] * 2, im.shape[1] * 2))
    expanded[::2, ::2] = im
    return filters.convolve(filters.convolve(expanded, filter_vec), filter_vec.T)


def build_gaussian_pyramid(im, max_levels, filter_size):
    """
    NOTES: (1) use scipy.ndimage.filters.convolve with 'filter_vec' TWICE - once rows and once columns.
           (2) down-sample (shrink) by taking the even indexes.
           (3) sample-up (make bigger) - by adding zeros in the odd places.
           (4) do not exceed max_levels AND minimum dim (row or col) is not smaller than 16 (16 is ok).
    :param im: a grayscale image with double values in [0,1] (output of ex1 read_image, representation=1)
    :param max_levels: the maximal number of levels in the resulting pyramid (includes the original image).
    :param filter_size: the size of the Gaussian filter (odd scalar represents a squared filter).
    :return: pyr - standard python array (NOT numpy), with maximum length of 'max_levels', where each element is a
             grayscale image.
             filter_vec - row vector of shape (1, 'filter_size') that was used for the pyramid construction. should be
             normalized.
    """
    # make filter_vec.
    # filter_vec = 0.25 * scp.linalg.pascal(filter_size, kind='lower')[-1]  # 0.25 for normalization
    filter_vec = [1, 1]
    for i in range(filter_size - 2):
        filter_vec = np.convolve(filter_vec, [1, 1])
    filter_vec = (filter_vec / np.sum(filter_vec)).reshape(1, len(filter_vec))

    # make pyr (out_put array), shaped according to the given data.
    number_of_levels = int(np.min([np.log2(im.shape[0]) - 3, np.log2(im.shape[1]) - 3, max_levels]))
    pyr = [im]

    for i in range(1, number_of_levels):
        pyr.append(reduce(pyr[i - 1], filter_vec))

    return pyr, filter_vec


def build_laplacian_pyramid(im, max_levels, filter_size):
    """

    :param im: a grayscale image with double values in [0,1] (output of ex1 read_image, representation=1)
    :param max_levels: the maximal number of levels in the resulting pyramid (includes the original image).
    :param filter_size: the size of the Gaussian filter (odd scalar represents a squared filter).
    :return: pyr, standard python array (NOT numpy), with maximum length of 'max_levels', where each element is a
             grayscale image.
    """
    # make Gaussian Pyramid:
    g_pyr, filter_vec = build_gaussian_pyramid(im, max_levels, filter_size)
    lap_filter_vec = filter_vec.copy() * 2

    # make pyr (out_put array), shaped according to the given data.
    number_of_levels = int(np.min([np.log2(im.shape[0]) - 3, np.log2(im.shape[1]) - 3, max_levels]))
    pyr = []

    for i in range(0, number_of_levels):
        if i == (number_of_levels - 1):
            pyr.append(g_pyr[i])
            break

        pyr.append(g_pyr[i] - expand(g_pyr[i + 1], lap_filter_vec))

    return pyr, filter_vec


#   (2) - Laplacian Pyramid Reconstruction
def laplacian_to_image(lpyr, filter_vec, coeff):
    """

    :param lpyr: e the Laplacian pyramid
    :param filter_vec: the filter that is generated by 'build_laplacian_pyramid()'
    :param coeff: python list. the list length is the same e as the number of levels in the pyramid lpyr.
    Before reconstructing the image img you should multiply each level i of the laplacian pyramid by its corresponding
    coefficient coeff[i].
    :return:
    """
    lap_filter_vec = (filter_vec * 2)
    im = lpyr[-1] * coeff[-1]
    for i in range((len(lpyr) - 2), -1, -1):
        im = expand(im, lap_filter_vec) + (lpyr[i] * coeff[i])  # multipling by coeff BEFORE expanding.
    return im


#   (3) - Pyramid Display
def render_pyramid(pyr, levels):
    """

    :param pyr: either a Gaussian or Laplacian pyramid.
    :param levels: levels is the number of levels (include the original) to present in the result ≤ max_levels
    :return: res - a single black image in which the pyramid levels of the given pyramid 'pyr' are stacked
             horizontally (after stretching the values to [0,1]).
    """
    rows_num = pyr[0].shape[0]  # y-asix length of the result.
    res = np.empty(shape=(rows_num, 0))

    for i in range(levels):
        # Stretch the current level to [0,1]:
        level_max, level_min = pyr[i].max(), pyr[i].min()
        stretched = (pyr[i] - level_min) / (level_max - level_min)

        # Pad with zeros below if needed, and stack with lastest version.
        zeros = np.zeros(shape=(rows_num - stretched.shape[0], stretched.shape[1]))
        new_level = np.vstack([stretched, zeros])
        res = np.hstack([res, new_level])

    return res


def display_pyramid(pyr, levels):
    """
    uses render_pyramid to internally render and then display the stacked pyramid image using plt.imshow()
    :param pyr: either a Gaussian or Laplacian pyramid.
    :param levels: levels is the number of levels (include the original) to present in the result ≤ max_levels
    :return: None
    """
    display_image = render_pyramid(pyr, levels)
    plt.figure()
    plt.imshow(display_image, cmap='gray')
    plt.axis('off')
    plt.show()


#   (4) - Pyramid Belnding
def pyramid_blending(im1, im2, mask, max_levels, filter_size_im, filter_size_mask):
    """

    Blending using this FORMULA:
    lpyr_new[i] = gpyr_mask[i] * lpyr_im1[i] + (1 - gpyr_mask[i]) * lpyr_im2[i]
    :param im1: input grayscale image to be blended
    :param im2: input grayscale image to be blended
    :param mask: is a boolean (i.e. dtype == np.bool) mask containing True and False representing which parts
                 of im1 and im2 should appear in the resulting im_blend. Note that a value of True corresponds to 1,
                 and False corresponds to 0.
    :param max_levels: the max_levels parameter you should use when generating the Gaussian and Laplacian pyramids
    :param filter_size_im: the size of the Gaussian filter (an odd scalar that represents a squared filter) which
                           defining the filter used in the construction of the Laplacian pyramids of im1 and im2.
    :param filter_size_mask: the size of the Gaussian filter(an odd scalar that represents a squared filter) which
                             defining the filter used in the construction of the Gaussian pyramid of mask
    :return:
    """
    mask = mask.astype("float64")
    #   Construct 2 Laplacian Pyramids of 'im1', 'im2'
    lpyr_im1, filter_vec = build_laplacian_pyramid(im1, max_levels, filter_size_im)
    lpyr_im2 = build_laplacian_pyramid(im2, max_levels, filter_size_im)[0]

    #   Construct Gaussian Pyramid for 'mask'
    gpyr_mask = build_gaussian_pyramid(mask, max_levels, filter_size_mask)[0]

    #   Construct a new Laplacian Pyramid, combined of the 3 pyramids, using FORMULA.
    lpyr_new = []
    for i in range(len(lpyr_im1)):
        lpyr_new.append(gpyr_mask[i] * lpyr_im1[i] + (1 - gpyr_mask[i]) * lpyr_im2[i])

    coeff = np.ones_like(lpyr_new)
    blended_img = laplacian_to_image(lpyr_new, filter_vec, coeff)
    return np.clip(blended_img, 0, 1)


# (5) - Usage Example:
def blending_example():
    """
    A blending example (Donald Trump an Catan/Settlers game cover).
    """
    im1 = read_image(relpath('externals/catan512.jpg'), 2)
    im2 = read_image(relpath('externals/trump_big_512.jpg'), 2)
    mask = np.round(read_image(relpath('externals/catan_trump_mask.jpg'), 1)).astype(np.bool)

    red = pyramid_blending(im1[:, :, 0], im2[:, :, 0], mask, 9, 5, 5)
    green = pyramid_blending(im1[:, :, 1], im2[:, :, 1], mask, 9, 5, 5)
    blue = pyramid_blending(im1[:, :, 2], im2[:, :, 2], mask, 9, 5, 5)
    im_blend = np.dstack((red, green, blue))

    figure, blocks = plt.subplots(2, 2)
    blocks[0, 0].imshow(im1)
    blocks[0, 1].imshow(im2)
    blocks[1, 0].imshow(mask, cmap='gray')
    blocks[1, 1].imshow(im_blend)
    plt.show()

    return np.clip(im1, 0, 1), np.clip(im2, 0, 1), np.clip(mask, 0, 1).astype(bool), np.clip(im_blend, 0, 1)

